#include<iostream>
#include<stdlib.h>
#include<string>
using namespace std;
int ip[64]={58,50,42,34,26,18,10,2,  //IP置换
	60,52,44,36,28,20,12,4,
	62,54,46,38,30,22,14,6,
	64,56,48,40,32,24,16,8,
	57,49,41,33,25,17,9,1,
	59,51,43,35,27,19,11,3,
	61,53,45,37,29,21,13,5,
	63,55,47,39,31,23,15,7
};
int ip_1[64]={40,8,48,16,56,24,64,32, //IP逆置换
	39,7,47,15,55,23,63,31,
	38,6,46,14,54,22,62,30,
	37,5,45,13,53,21,61,29,
	36,4,44,12,52,20,60,28,
	35,3,43,11,51,19,59,27,
	34,2,42,10,50,18,58,26,
	33,1,41,9,49,17,57,25
};
int E[48]={32,1,2,3,4,5, //E扩展
	4,5,6,7,8,9,
	8,9,10,11,12,13,
	12,13,14,15,16,17,
	16,17,18,19,20,21,
	20,21,22,23,24,25,
	24,25,26,27,28,29,
	28,29,30,31,32,1
};
int P[32]={16,7,20,21,  //P置换
	29,12,28,17,
	1,15,23,26,
	5,18,31,10,
	2,8,24,14,
	32,27,3,9,
	19,13,30,6,
	22,11,4,25
};
int S[8][4][16]={  //S盒
	//S1
	14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,
	0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,
	4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,
	15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,
	//S2
	15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,
	3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,
	0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,
	13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,
	//S3
	10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,
	13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,
	13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,
	1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,
	//S4
	7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,
	13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,
	10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,
	3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,
	//S5
	2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,
	14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,
	4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,
	11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,
	//S6
	12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,
	10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,
	9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,
	4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,
	//S7
	4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,
	13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,
	1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,
	6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,
	//S8
	13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,
	1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,
	7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,
	2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11
};
int PC_1[56]={57,49,41,33,25,17,9,  //PC-1置换选择
	1,58,50,42,34,26,18,
	10,2,59,51,43,35,27,
	19,11,3,60,52,44,36,
	63,55,47,39,31,23,15,
	7,62,54,46,38,30,22,
	14,6,61,53,45,37,29,
	21,13,5,28,20,12,4
};
int PC_2[48]={14,17,11,24,1,5, //PC-2置换选择
	3,28,15,6,21,10,
	23,19,12,4,26,8,
	16,7,27,20,13,2,
	41,52,31,37,47,55,
	30,40,51,45,33,48,
	44,49,39,56,34,53,
	46,42,50,36,29,32
};
int shift[16]={1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1}; //左循环移位位数
string K[16]; //产生的16轮子密钥
void keyGeneration(string initialK){ //子密钥生成，传入的参数为64位
	while(initialK.length() < 64){  //密钥的长度如果小于64，则补0
		initialK += '0';
	}
	string LK; //先将64位初始密钥变成56位,并分成两半
	string RK;
	for(int i = 0; i < 56; i++){ //置换选择1
		if(i < 28){
			LK+= initialK[PC_1[i]-1];
		}else{
			RK+= initialK[PC_1[i]-1];
		}
	}
	for(int i = 0; i < 16; i++){ //循环生成16轮数子密钥
		LK = LK.substr(shift[i],28-shift[i]) + LK.substr(0,shift[i]);
		RK = RK.substr(shift[i],28-shift[i]) + RK.substr(0,shift[i]);
		string temp = LK + RK;
		for(int j = 0; j < 48; j++){
			K[i] += temp[PC_2[j]-1]; //置换选择2
		}
	}
}
string XOR(string op1,string op2){ //异或操作
	string result;
	for(int i = 0; i < op1.length(); i++){
		if(op1[i]==op2[i]) result+='0';
		else result+='1';
	}
	return result;
}
string toBinary(int i) { //整数转成二进制字符串,利用短除法的余数并按顺序翻转得到二进制数
	int k = 0;
	string result;
	while (k < 4) { //循环四次表示二进制数是4位，不足4位的补0
		if (i){
			result += ((i % 2) + '0');
			i /= 2;
		}
		else result += '0';
		k++;
	}
	reverse(result.begin(), result.end()); 
	return result;
}
string Encryption(string text){ //DES加密,传入的分组明文长度为64位
	string txt; //初始置换
	for(int i = 0; i < 64; i++){
		txt += text[ip[i]-1];
	}
	string LT = txt.substr(0,32);
	string RT = txt.substr(32,32);
	for(int i = 0; i < 16; i++ ){ //16轮加密
		string extensionE;
		for(int j = 0; j < 48; j++ ){ //E扩展
			extensionE += RT[E[j]-1];
		}
		string xorTxt = XOR(extensionE,K[i]); //XOR
		string sTxt;
		for(int j = 0; j < 48; j = j + 6){ //S盒代换
			int s = j/6;  //s,m,n分别是S盒数组的三个参数
			int m = 0,n = 0;
			m += (xorTxt[j] - '0')*2; //行号是第一位和第六位组成的二进制数
			m += xorTxt[j+5] - '0';
			n += (xorTxt[j+1] - '0')*8; //列好是中间四位组成的二进制数
			n += (xorTxt[j+2] - '0')*4;
			n += (xorTxt[j+3] - '0')*2;
			n += (xorTxt[j+4] - '0');
			int sbox = S[s][m][n];
			sTxt += toBinary(sbox);
		}
		string pTxt;
		for(int j = 0; j < 32; j++){ //P置换
			pTxt += sTxt[P[j]-1];
		}
		string temp = RT;
		RT = XOR(LT,pTxt);
		LT = temp;
	}
	string LRswap = RT + LT; //左右交换
	string result;
	for(int i = 0; i < 64; i++){ //逆初始置换
		result += LRswap[ip_1[i]-1];
	}
	return result;
}
string Decryption(string text){ //DES解密,传入的分组密文长度为64位
	string txt; //初始置换
	for(int i = 0; i < 64; i++){
		txt += text[ip[i]-1];
	}
	string LT = txt.substr(0,32);
	string RT = txt.substr(32,32);
	for(int i = 0; i < 16; i++ ){ //16轮加密
		string extensionE;
		for(int j = 0; j < 48; j++ ){ //E扩展
			extensionE += RT[E[j]-1];
		}
		string xorTxt = XOR(extensionE,K[15-i]); //XOR
		string sTxt;
		for(int j = 0; j < 48; j = j + 6){ //S盒代换
			int s = j/6;  //s,m,n分别是S盒数组的三个参数
			int m = 0,n = 0;
			m += (xorTxt[j] - '0')*2; //行号是第一位和第六位组成的二进制数
			m += xorTxt[j+5] - '0';
			n += (xorTxt[j+1] - '0')*8; //列好是中间四位组成的二进制数
			n += (xorTxt[j+2] - '0')*4;
			n += (xorTxt[j+3] - '0')*2;
			n += (xorTxt[j+4] - '0');
			int sbox = S[s][m][n];
			sTxt += toBinary(sbox);
		}
		string pTxt;
		for(int j = 0; j < 32; j++){ //P置换
			pTxt += sTxt[P[j]-1];
		}
		string temp = RT;
		RT = XOR(LT,pTxt);
		LT = temp;
	}
	string LTswap = RT + LT; //左右交换
	string result;
	for(int i = 0; i < 64; i++){ //逆初始置换
		result += LTswap[ip_1[i]-1];
	}
	return result;
}
void compare(string s1,string s2){ //测试雪崩效应时调用比较的函数
	int sum = 0;
	for(int i = 0; i < 64; i++){
		if(s1[i]!=s2[i]) sum++;
	}
	cout<<"改变后有："<<sum<<"位不相同"<<endl;
}
int main(){
	cout<<"请输入二进制初始密钥："; //0001000000110001011011100000001010001100100011110011101101001010
	                                //0000000100000001000000010000000100000001000000010000000100000001
	//
	string key;
	cin>>key;
	keyGeneration(key);
	cout<<"请输入需要加密的二进制数："; //0000000000000000000000000000000000000000000000000000000000000000
	                                    //1001010111111000101001011110010111011101001100011101100100000000
	                                    //1101110101111111000100100001110010100101000000010101011000011001
	                                    //0010111010000110010100110001000001001111001110000011010011101010
										//0100101111010011100010001111111101101100110110000001110101001111
	                                    //0010000010111001111001110110011110110010111110110001010001010110
	                                    //0101010101010111100100111000000011010111011100010011100011101111
	                                    //0110110011000101110111101111101010101111000001000101000100101111
	                                    //0000110110011111001001111001101110100101110110000111001001100000
	                                    //1101100100000011000110110000001001110001101111010101101000001010
	string text;
	cin>>text;
	string encrypt = Encryption(text);
    cout<<"DES加密后密文为："<<encrypt<<endl;
	string decrypt = Decryption(encrypt);
	cout<<"DES解密后明文为："<<decrypt<<endl;

	//测试雪崩效应，固定明文和密钥，每次改变一位密文：
	for(int i = 0; i < 64; i=i+8){
		string change = encrypt;
		if(change[i] == '0') change[i] = '1';
		else change[i] = '0';
	    string d1 = Decryption(change);
	    compare(d1,decrypt);
	}

	system("pause");
	return 0;
}



